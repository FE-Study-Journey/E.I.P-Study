# 🌟 정보처리기사 실기 - C언어 정리

## ✅ C언어 파트를 들어가기 전 주의사항

1. **포인터 주소를 묻는 문제는 출제되지 않는다.**
2. **줄바꿈이 이뤄졌는지 꼭 확인할 것.**
3. **동작하지 않는 코드는 출제되지 않는다.**

---

## 📌 형식 지정자(format specifier)

C언어에서 `printf()`와 `scanf()`에서 사용하는 형식 지정자를 정리합니다.

| 형식 지정자 | 설명        | 해당 변수 유형    |
| ----------- | ----------- | ----------------- |
| `%d`        | 정수 출력   | `int`             |
| `%f`        | 실수 출력   | `float`, `double` |
| `%c`        | 문자 출력   | `char`            |
| `%s`        | 문자열 출력 | `char 배열`       |

---

## 📌 `&`와 `*` (주소 연산자와 포인터)

### ✅ 주소 연산자 `&`

- 변수의 메모리 주소를 가져와서 포인터 변수에 저장할 때 사용됩니다.
- 예제:

```c
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr = &num; // num의 주소를 ptr에 저장
    printf("ptr이 가리키는 값: %d\n", *ptr);
    return 0;
}
```

#### 실행 결과

```
ptr이 가리키는 값: 10
```

### ✅ 포인터 연산자 `*`

- 포인터 변수를 통해 메모리 주소에 저장된 값을 참조(역참조)할 때 사용됩니다.
- 예제:

```c
#include <stdio.h>

int main() {
    int num = 42;
    int *ptr = &num;
    *ptr = 100; // 포인터를 이용해 num 값 변경
    printf("num의 값: %d\n", num);
    return 0;
}
```

#### 실행 결과

```
num의 값: 100
```

### ✅ `&`와 `*` 정리

| 연산자 | 의미                        | 예제            |
| ------ | --------------------------- | --------------- |
| `&`    | 변수의 메모리 주소 가져오기 | `ptr = &num;`   |
| `*`    | 포인터가 가리키는 값 참조   | `value = *ptr;` |

---

## 📌 구조체(struct) 정리

C언어에서 구조체는 여러 데이터를 하나로 묶어 관리할 수 있는 자료형입니다.

```c
#include <stdio.h>

struct Student {
    char name[20];
    int age;
};

int main() {
    struct Student s1 = {"홍길동", 20};
    printf("이름: %s, 나이: %d\n", s1.name, s1.age);
    return 0;
}
```

#### 실행 결과

```
이름: 홍길동, 나이: 20
```

### ✅ 구조체 정리

| 키워드   | 설명                           |
| -------- | ------------------------------ |
| `struct` | 구조체 선언 키워드             |
| `.`      | 구조체 멤버 접근 연산자        |
| `->`     | 구조체 포인터 멤버 접근 연산자 |

---

## 📌 배열(Array) 정리

C언어에서 배열은 같은 자료형의 데이터를 연속적으로 저장하는 자료구조입니다.

```c
#include <stdio.h>

int main() {
    int arr[3] = {1, 2, 3};
    printf("첫 번째 요소: %d\n", arr[0]);
    printf("두 번째 요소: %d\n", arr[1]);
    printf("세 번째 요소: %d\n", arr[2]);
    return 0;
}
```

#### 실행 결과

```
첫 번째 요소: 1
두 번째 요소: 2
세 번째 요소: 3
```

### ✅ 배열 정리

| 개념          | 설명                       |
| ------------- | -------------------------- |
| `arr[n]`      | n번째 요소에 접근          |
| `sizeof(arr)` | 배열의 크기 계산           |
| `arr`         | 배열의 첫 번째 요소의 주소 |

### ✅ 배열과 포인터 연산

배열은 포인터처럼 동작할 수 있으며, `arr + n` 형식으로 특정 위치의 요소에 접근할 수 있습니다.

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    printf("arr[2]: %d\n", arr[2]);
    printf("*(arr + 2): %d\n", *(arr + 2));
    return 0;
}
```

#### 실행 결과

```
arr[2]: 30
*(arr + 2): 30
```

배열의 특정 요소를 가리킬 때, `arr[n]`은 `*(arr + n)`과 동일하게 동작합니다.

---

## ✅ 문제를 통한 정리

### 수제비 모의고사 01회 04번

> 다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>

int main() {
  int a[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  int *p = a[1] + 2;
  int *q = &a[0][1];

  printf("%d", p[1]);
  printf("%d", q[2]);
  return 0;
}
```

#### 실행 결과

```
74
```

### ✅ 문제 풀이

#### 1. 배열의 메모리 배치

2차원 배열 `a`의 메모리 배치는 실제로 연속된 1차원 배열처럼 저장됩니다.

```
a[0][0] = 1   a[0][1] = 2   a[0][2] = 3
a[1][0] = 4   a[1][1] = 5   a[1][2] = 6
a[2][0] = 7   a[2][1] = 8   a[2][2] = 9
```

#### 2. 포인터 `p`의 값

```c
int *p = a[1] + 2;
```

- `a[1]`은 두 번째 행(인덱스 1)의 시작 주소(`&a[1][0]`).
- `a[1] + 2`는 두 번째 행에서 오른쪽으로 2칸 이동한 곳(`&a[1][2]`).
- 즉, `p`는 `a[1][2]`, 즉 `6`을 가리킴.

`p[1]`은?

- `p[1]`은 `p`가 가리키는 위치에서 1칸 오른쪽의 값.
- `p`는 `a[1][2]`(=6)을 가리키므로, `p[1]`은 `a[2][0]`(=7)을 의미.

**결론**: `p[1] = 7`

#### 3. 포인터 `q`의 값

```c
int *q = &a[0][1];
```

- `q`는 `a[0][1]`(=2)의 주소를 저장.

`q[2]`은?

- `q[2]`는 `q`가 가리키는 위치에서 2칸 오른쪽의 값.
- `q`는 `a[0][1]`(=2)을 가리키므로,
  - `q[1]` → `a[0][2]`(=3)
  - `q[2]` → `a[1][0]`(=4)

**결론**: `q[2] = 4`

#### 4. 최종 출력

```c
printf("%d", p[1]);  // 출력: 7
printf("%d", q[2]);  // 출력: 4
```

즉, 최종적으로 출력되는 값은 `74` 입니다. 🎯

---

### 수제비 모의고사 01회 07번

> 다음은 C언어 코드이다. 밑줄에 알맞은 코드를 작성하시오.

```c
#include <stdio.h>
int add(int i , int j) {
  return i + j;
}
int sub(int i , int j) {
  return i - j;
}

int main() {
  int (*pf)(int, int);
  // __1번__;
  printf("%d", pf(5, 4));
  // __2번__;
  printf("%d", pf(5, 4));
  return 0;
}
```

**[출력결과]**

```
91
```

### ✅ 문제 풀이

#### 함수 포인터란?

- `int (*pf)(int, int);`

  → `pf`는 두 개의 `int`를 매개변수로 받고 `int`를 반환하는 함수 포인터입니다.
  → 즉, `add` 또는 `sub` 함수를 가리킬 수 있습니다.

#### 빈칸 `1번`과 `2번`에 들어갈 코드

**1번: 함수 포인터 초기화**

```c
pf = add;
```

- `pf`가 `add` 함수를 가리키도록 설정합니다.

**2번: 함수 포인터 변경**

```c
pf = sub;
```

- `pf`를 `sub` 함수로 변경하여 실행합니다.

#### 해설

- `pf = add;`

  - `pf(5, 4)`는 `add(5, 4)` 실행 → `5 + 4 = 9`

- `pf = sub;`
  - `pf(5, 4)`는 `sub(5, 4)` 실행 → `5 - 4 = 1`

결과적으로 `91` 이 출력됩니다. 🎯
